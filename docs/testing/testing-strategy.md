# Стратегія Тестування Проєкту
Мета: Цей документ описує наш підхід до тестування, його еволюцію та інтеграцію в процес розробки для забезпечення якості та надійності нашого сервісу доставки.

## 1. Поточний статус тестування

На поточному етапі наше тестування складається з:
Мануальне тестування (Desk-Check): Розробники проводять базове мануальне тестування функціоналу (наприклад, "чи працює флоу замовлення") перед створенням Pull Request.
Юніт-тестування: Ми маємо базовий набір юніт-тестів для бекенду (Django), написаних поки без використання pytest. Покриття коду наразі знаходиться на початковому рівні, і його збільшення для ключової бізнес-логіки (моделі, сервіси) є пріоритетом.

## 2. Плани для інтеграційних, системних та приймальних тестів

Наша стратегія тестування буде розширюватися разом з проєктом:

### Інтеграційні тести

Мета: Перевірка коректної взаємодії між окремими модулями.
План: Ми додамо інтеграційні тести, що фокусуватимуться на:

- Взаємодії React-компонентів з нашим DRF API (перевірка запитів та рендерінгу отриманих даних).
- Коректній роботі API з базою даних Postgres (перевірка ендпоінтів, що створюють або модифікують дані).
- Інструменти: django тести (можливо, пізніше pytest) (для тестування ендпоінтів DRF) та React Testing Library (для тестування React-компонентів, що роблять API-виклики).

### Системні тести (End-to-End)

Мета: Перевірка всього додатку з точки зору кінцевого користувача.
План: На даному етапі ми зосереджені на юніт- та інтеграційних тестах. Реалізація E2E-тестів для критичних "user flows" (шляхів користувача) є нашим наступним кроком після стабілізації API. Ці тести будуть покривати:

- Реєстрація, логін та JWT-аутентифікація.
- Перегляд меню та додавання страви у кошик.
- Оформлення та відправка замовлення (включаючи валідацію форми).
- Менеджерський CRUD.
- Інтерфейси/взаємодію кухні
- Інтерфейси/взаємодію кур'єрів.

Інструменти: Ми молги б дослідити інструменти для E2E тестування, такі як Cypress або Playwright, але ще не починали.

### Приймальні тести (UAT)

Мета: Підтвердження, що функціонал відповідає вимогам замовника (у нашому випадку – критеріям приймання для User Story).
План: Бажано, приймальне тестування буде проводитися у форматі "демо" в кінці кожного спринту. Ми будемо проходити по "Acceptance Criteria" кожної реалізованої Story. (На практиці у нас неммає толком спринтів і ми не ще чистили user stories...)

## 3. Плани для нефункціонального тестування

У рамках навчального проєкту ми фокусуємося на функціональності, однак ми визначили наступні кроки:
Тестування продуктивності:
План: На поточному етапі ми не плануємо проводити поглиблене тестування продуктивності чи часу завантаження, окрім базових перевірок в інструментах розробника. Ми плануємо повернутися до цього питання (з можливим використанням k6 або JMeter для API) на пізніших стадіях проєкту, коли основний функціонал буде реалізовано.

Тестування безпеки:
План: Ми дотримуємося базових практик безпеки: валідація всіх вхідних даних (DRF serializers), використання змінних середовища (.env) для секретів, захист від XSS, CSRF (Django має вбудований захист) та SQL-ін'єкцій. Спеціалізоване тестування безпеки (пен-тести) не планується.

Тестування зручності:
План: якщо ми до цього доберемось, зробимо resesarch, як правильно проводити тести на людях, і назбираємо студентів, щоб потицяли наш сайт.

## 4. Інтеграція у CI/CD Pipeline

Ми використовуємо GitHub Actions для автоматизації наших процесів (він поки приліг, не зважайте).
Стратегія інтеграції тестів:

On Push (до Pull Request):
Кроки: Автоматично запускаються лінтери та форматери коду (Flake8, isort, black) та повний набір юніт-тестів (ванліьні django).
Мета: Швидкий фідбек для розробника та підтримка чистоти коду.

On Pull Request (до main / develop):
Кроки: Додатково до кроків "On Push", поки не запускається набір інтеграційних тестів (тести API ендпоінтів).
Правило: Мердж у main буде заблоковано, якщо будь-який з тестів (юніт або інтеграційний) чи лінтерів провалився.

After Merge (до main) (на майбутнє):
Кроки: Повний набір системних (E2E) тестів (Cypress/Playwright) запускаємо вручну на main (staging середовище? але у нас немає), оскільки вони тривають значно довше.
